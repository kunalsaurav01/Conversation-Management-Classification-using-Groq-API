# -*- coding: utf-8 -*-
"""Untitled28.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mbUFfAVuQogQRjb6lhAR63SyRfUFJ8vd
"""

!pip install google-generativeai requests

import json
import re
from typing import List, Dict, Any, Optional
from datetime import datetime
import google.generativeai as genai

# =============================================================================
# CONFIGURATION
# =============================================================================

# Google Gemini API Configuration
GEMINI_API_KEY = "AIzaSyDNV5V-xh5TdOj4aVOCBj_KLY9JKhWzJ1s"  # Replace with your actual API key
# Get your free API key from: https://makersuite.google.com/app/apikey

# Configure Gemini
genai.configure(api_key=GEMINI_API_KEY)

# Initialize Gemini model
model = genai.GenerativeModel('gemini-pro')

# =============================================================================
# TASK 1: CONVERSATION HISTORY MANAGEMENT WITH SUMMARIZATION
# =============================================================================

class ConversationManager:
    """
    Manages conversation history with intelligent summarization capabilities.
    Supports truncation by turns or length, and periodic summarization.
    """

    def __init__(self, max_turns: int = 10, max_chars: int = 5000,
                 summarization_interval: int = 3):
        self.conversation_history: List[Dict[str, str]] = []
        self.max_turns = max_turns
        self.max_chars = max_chars
        self.summarization_interval = summarization_interval
        self.turn_counter = 0
        self.summary = ""

    def add_message(self, role: str, content: str):
        """Add a new message to conversation history"""
        message = {
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat()
        }
        self.conversation_history.append(message)
        self.turn_counter += 1

        # Check if periodic summarization is needed
        if self.turn_counter % self.summarization_interval == 0:
            print(f"\n🔄 Performing periodic summarization (Turn {self.turn_counter})")
            self.perform_periodic_summarization()

    def truncate_by_turns(self, n_turns: int) -> List[Dict[str, str]]:
        """Truncate conversation to last n turns"""
        return self.conversation_history[-n_turns:] if n_turns > 0 else []

    def truncate_by_length(self, max_chars: int) -> List[Dict[str, str]]:
        """Truncate conversation to fit within character limit"""
        truncated = []
        char_count = 0

        # Start from most recent messages
        for message in reversed(self.conversation_history):
            message_length = len(message["content"])
            if char_count + message_length <= max_chars:
                truncated.insert(0, message)
                char_count += message_length
            else:
                break

        return truncated

    def summarize_conversation(self, messages: List[Dict[str, str]]) -> str:
        """Generate summary of conversation using Gemini API"""
        if not messages:
            return "No conversation to summarize."

        # Prepare conversation text for summarization
        conversation_text = "\n".join([
            f"{msg['role'].title()}: {msg['content']}"
            for msg in messages
        ])

        try:
            prompt = f"""Summarize the following conversation concisely, capturing key points and context. Keep it under 200 words.

Conversation to summarize:
{conversation_text}

Summary:"""

            response = model.generate_content(prompt)
            return response.text.strip()
        except Exception as e:
            return f"Summarization failed: {str(e)}"

    def perform_periodic_summarization(self):
        """Replace old conversation history with summary"""
        if len(self.conversation_history) >= self.summarization_interval:
            # Summarize all but the most recent message
            messages_to_summarize = self.conversation_history[:-1]
            summary = self.summarize_conversation(messages_to_summarize)

            # Replace history with summary + latest message
            latest_message = self.conversation_history[-1]
            self.conversation_history = [
                {
                    "role": "system",
                    "content": f"Previous conversation summary: {summary}",
                    "timestamp": datetime.now().isoformat()
                },
                latest_message
            ]
            self.summary = summary
            print(f"✅ Conversation summarized and history compressed")

    def get_conversation_stats(self) -> Dict[str, Any]:
        """Get statistics about current conversation"""
        total_chars = sum(len(msg["content"]) for msg in self.conversation_history)
        return {
            "total_messages": len(self.conversation_history),
            "total_characters": total_chars,
            "turn_counter": self.turn_counter,
            "has_summary": bool(self.summary)
        }

    def display_conversation(self, truncation_type: str = "none", limit: int = None):
        """Display conversation with optional truncation"""
        print(f"\n{'='*60}")
        print(f"CONVERSATION DISPLAY ({truncation_type.upper()})")
        print(f"{'='*60}")

        if truncation_type == "turns" and limit:
            messages = self.truncate_by_turns(limit)
            print(f"📋 Showing last {limit} turns:")
        elif truncation_type == "chars" and limit:
            messages = self.truncate_by_length(limit)
            print(f"📋 Showing conversation within {limit} characters:")
        else:
            messages = self.conversation_history
            print("📋 Showing full conversation:")

        for i, msg in enumerate(messages, 1):
            role_emoji = "🤖" if msg["role"] == "assistant" else "👤" if msg["role"] == "user" else "📋"
            print(f"{role_emoji} {msg['role'].title()}: {msg['content']}")
            print(f"   ⏰ {msg.get('timestamp', 'N/A')}")
            print()

        stats = self.get_conversation_stats()
        print(f"📊 Stats: {stats['total_messages']} messages, {stats['total_characters']} chars")
        if self.summary:
            print(f"📝 Summary available: {self.summary[:100]}...")

# =============================================================================
# TASK 2: JSON SCHEMA CLASSIFICATION & INFORMATION EXTRACTION
# =============================================================================

class InformationExtractor:
    """
    Extracts structured information from chat conversations using Gemini API
    with structured JSON output parsing.
    """

    def __init__(self):
        self.extraction_schema = {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Full name of the person"
                },
                "email": {
                    "type": "string",
                    "description": "Email address"
                },
                "phone": {
                    "type": "string",
                    "description": "Phone number"
                },
                "location": {
                    "type": "string",
                    "description": "Location, city, or address"
                },
                "age": {
                    "type": "integer",
                    "description": "Age in years"
                },
                "confidence_score": {
                    "type": "number",
                    "description": "Confidence score (0-1) for the extraction quality"
                }
            },
            "required": ["confidence_score"]
        }

    def extract_information(self, chat_text: str) -> Dict[str, Any]:
        """
        Extract information from chat using Gemini API with structured prompt
        """
        prompt = f"""You are an information extraction assistant. Extract the following information from the chat conversation and return it as a JSON object:

Required fields to extract (only include if explicitly mentioned):
- name: Person's full name
- email: Email address
- phone: Phone number
- location: Location, city, or address
- age: Age in years
- confidence_score: Your confidence (0.0-1.0) in the extraction quality

Rules:
1. Only extract information that is explicitly mentioned in the chat
2. If information is not available, do not include that field in the JSON
3. Always include confidence_score
4. Return only valid JSON, no additional text

Chat conversation:
{chat_text}

Extract the information as JSON:"""

        try:
            response = model.generate_content(prompt)
            json_text = response.text.strip()

            # Clean up the response to extract JSON
            json_text = self.clean_json_response(json_text)

            # Parse JSON
            extracted_info = json.loads(json_text)
            return self.validate_extraction(extracted_info)

        except json.JSONDecodeError as e:
            return {"error": f"Invalid JSON in response: {str(e)}", "confidence_score": 0.0}
        except Exception as e:
            return {"error": f"Extraction failed: {str(e)}", "confidence_score": 0.0}

    def clean_json_response(self, response_text: str) -> str:
        """Clean and extract JSON from Gemini response"""
        # Remove markdown code blocks if present
        response_text = re.sub(r'```json\s*', '', response_text)
        response_text = re.sub(r'```\s*$', '', response_text)

        # Find JSON object in the response
        json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
        if json_match:
            return json_match.group(0)

        return response_text

    def validate_extraction(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Validate extracted data against schema"""
        validated = {"confidence_score": data.get("confidence_score", 0.5)}

        # Validate each field
        if "name" in data and isinstance(data["name"], str) and data["name"].strip():
            validated["name"] = data["name"].strip()

        if "email" in data and self.is_valid_email(str(data["email"])):
            validated["email"] = str(data["email"]).strip()

        if "phone" in data and isinstance(data["phone"], str) and data["phone"].strip():
            validated["phone"] = data["phone"].strip()

        if "location" in data and isinstance(data["location"], str) and data["location"].strip():
            validated["location"] = data["location"].strip()

        if "age" in data and isinstance(data["age"], (int, float)) and 0 < data["age"] < 150:
            validated["age"] = int(data["age"])

        return validated

    def is_valid_email(self, email: str) -> bool:
        """Basic email validation"""
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return bool(re.match(pattern, email))

    def format_extraction_result(self, result: Dict[str, Any], chat_sample: str) -> str:
        """Format extraction results for display"""
        output = f"\n{'='*50}\n"
        output += "INFORMATION EXTRACTION RESULT\n"
        output += f"{'='*50}\n"
        output += f"📝 Original Chat:\n{chat_sample[:200]}...\n\n"
        output += "🔍 Extracted Information:\n"

        for key, value in result.items():
            if key != "error" and key != "confidence_score":
                emoji = {"name": "👤", "email": "📧", "phone": "📞", "location": "📍", "age": "🎂"}.get(key, "📋")
                output += f"{emoji} {key.title()}: {value}\n"

        if "error" in result:
            output += f"❌ Error: {result['error']}\n"

        confidence = result.get("confidence_score", 0)
        confidence_emoji = "🟢" if confidence > 0.8 else "🟡" if confidence > 0.5 else "🔴"
        output += f"{confidence_emoji} Confidence Score: {confidence:.2f}\n"

        return output

# =============================================================================
# DEMONSTRATION & TESTING
# =============================================================================

def demonstrate_task1():
    """Demonstrate conversation management and summarization"""
    print("🚀 TASK 1: CONVERSATION MANAGEMENT & SUMMARIZATION")
    print("="*60)

    # Initialize conversation manager
    conv_manager = ConversationManager(
        max_turns=5,
        max_chars=1000,
        summarization_interval=3
    )

    # Sample conversation data
    sample_conversations = [
        ("user", "Hi, I'm looking for help with my Python project. Can you assist me?"),
        ("assistant", "Of course! I'd be happy to help with your Python project. What specific area do you need assistance with?"),
        ("user", "I'm working on a web scraping application using BeautifulSoup, but I'm having trouble parsing nested HTML elements."),
        ("assistant", "Web scraping with BeautifulSoup can be tricky with nested elements. Can you share the specific HTML structure you're trying to parse?"),
        ("user", "Here's the HTML: <div class='container'><div class='item'><span class='title'>Product Name</span><span class='price'>$29.99</span></div></div>"),
        ("assistant", "I can help you parse that structure. You'll want to use CSS selectors or find methods to navigate the nested elements effectively."),
        ("user", "Could you show me a code example for extracting both the title and price?"),
        ("assistant", "Certainly! Here's a code example using BeautifulSoup to extract both elements from your HTML structure.")
    ]

    # Add messages and demonstrate periodic summarization
    for i, (role, content) in enumerate(sample_conversations, 1):
        print(f"\n📝 Adding message {i}:")
        print(f"   {role}: {content[:50]}...")
        conv_manager.add_message(role, content)

        # Show stats after each addition
        stats = conv_manager.get_conversation_stats()
        print(f"   📊 Current stats: {stats}")

    # Demonstrate different truncation methods
    print("\n" + "="*60)
    print("TRUNCATION DEMONSTRATIONS")
    print("="*60)

    # Display with different truncation settings
    conv_manager.display_conversation("none")
    conv_manager.display_conversation("turns", 3)
    conv_manager.display_conversation("chars", 500)

def demonstrate_task2():
    """Demonstrate information extraction and classification"""
    print("\n\n🚀 TASK 2: JSON SCHEMA CLASSIFICATION & INFORMATION EXTRACTION")
    print("="*70)

    # Initialize information extractor
    extractor = InformationExtractor()

    # Sample chat conversations for information extraction
    sample_chats = [
        """
        User: Hi, I'd like to set up an account.
        Assistant: Sure! I can help you with that. What's your name?
        User: My name is John Smith. I live in New York City.
        Assistant: Thanks John! What's your email address?
        User: It's john.smith@email.com and my phone number is 555-123-4567.
        Assistant: Great! And how old are you?
        User: I'm 28 years old.
        """,

        """
        User: Hello, I need to update my profile information.
        Assistant: I can help with that. What information needs updating?
        User: Well, I moved recently. I now live in San Francisco, California.
        Assistant: Got it. Is your contact information still current?
        User: My email sarah.johnson@company.com is still good, but I haven't updated my age. I just turned 35 last month.
        """,

        """
        User: Can you help me with my order?
        Assistant: Of course! Can I get some details from you?
        User: My name is Mike Wilson and I'm calling from Chicago.
        Assistant: Thanks Mike. Do you have a phone number we can reach you at?
        User: Yes, it's 312-555-9876. I don't really like giving out my email though.
        Assistant: That's fine, we can work with just the phone number.
        """
    ]

    # Process each sample chat
    for i, chat in enumerate(sample_chats, 1):
        print(f"\n📋 PROCESSING SAMPLE CHAT {i}:")
        print("-" * 40)

        # Extract information
        result = extractor.extract_information(chat)

        # Display formatted result
        print(extractor.format_extraction_result(result, chat))

        # Validate against schema
        print("✅ Schema Validation:")
        required_fields = extractor.extraction_schema.get("required", [])
        for field in required_fields:
            if field in result:
                print(f"   ✓ Required field '{field}' present")
            else:
                print(f"   ❌ Required field '{field}' missing")

        optional_fields = ["name", "email", "phone", "location", "age"]
        extracted_optionals = [f for f in optional_fields if f in result]
        print(f"   📋 Extracted optional fields: {extracted_optionals}")

def main():
    """Main function to run both demonstrations"""
    print("🎯 GEMINI API CONVERSATION MANAGEMENT & CLASSIFICATION")
    print("🎯 Assignment Implementation (Free API Version)")
    print("="*60)
    print("📋 Features Implemented:")
    print("   ✅ Conversation history management")
    print("   ✅ Summarization with customizable truncation")
    print("   ✅ Periodic summarization (every k-th turn)")
    print("   ✅ JSON schema-based information extraction")
    print("   ✅ Google Gemini API integration (FREE!)")
    print("   ✅ Validation and error handling")
    print("="*60)

    # Check API key
    if GEMINI_API_KEY == "your_gemini_api_key_here":
        print("⚠️  WARNING: Please replace 'your_gemini_api_key_here' with your actual Gemini API key!")
        print("   You can get your FREE API key from: https://makersuite.google.com/app/apikey")
        print("   📋 Steps to get your key:")
        print("      1. Go to https://makersuite.google.com/app/apikey")
        print("      2. Sign in with your Google account")
        print("      3. Click 'Create API Key'")
        print("      4. Copy the key and paste it above")
        return

    try:
        # Test API connection
        test_response = model.generate_content("Hello! Please respond with 'API connection successful'")
        print(f"🟢 API Connection Test: {test_response.text}")

        # Run demonstrations
        demonstrate_task1()
        demonstrate_task2()

        print("\n" + "="*60)
        print("✅ ASSIGNMENT COMPLETED SUCCESSFULLY!")
        print("📋 Both Task 1 and Task 2 have been implemented and demonstrated.")
        print("🔗 Next steps:")
        print("   1. Upload this notebook to Google Colab")
        print("   2. Add your FREE Gemini API key")
        print("   3. Run all cells to see the output")
        print("   4. Push to GitHub repository")
        print("="*60)

    except Exception as e:
        print(f"❌ Error during execution: {str(e)}")
        print("Please check your API key and internet connection.")
        print("Make sure you have a valid Gemini API key from: https://makersuite.google.com/app/apikey")

# =============================================================================
# RUN DEMONSTRATIONS
# =============================================================================

if __name__ == "__main__":
    main()

# =============================================================================
# ADDITIONAL UTILITIES FOR TESTING
# =============================================================================

def test_individual_components():
    """Test individual components separately for debugging"""
    print("\n🔧 COMPONENT TESTING MODE")
    print("="*40)

    # Test conversation manager
    print("Testing ConversationManager...")
    cm = ConversationManager(summarization_interval=2)
    cm.add_message("user", "Hello")
    cm.add_message("assistant", "Hi there!")
    cm.add_message("user", "How are you?")
    print(f"✅ ConversationManager: {len(cm.conversation_history)} messages")

    # Test information extractor
    print("Testing InformationExtractor...")
    ie = InformationExtractor()
    test_chat = "My name is Alice and my email is alice@test.com"
    result = ie.extract_information(test_chat)
    print(f"✅ InformationExtractor: {list(result.keys())}")

# Uncomment the line below to run component tests instead of full demo
# test_individual_components()